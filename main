from random import *
from enum import Enum
import time
import socket
import json
import threading



roleDes= {"Diablotin":"Le Diablotin est le chef des Démons. Chaque nuit, il choisit de tuer quelqu'un. Il est mis au courant de trois rôles qui ne sont pas présents dans la partie. Si le Diablotin meurt, les Citadins gagnent. Mais s'il décide de se viser lui-même la nuit, il meurt et un Sbire choisi aléatoirement (la Femme Écarlate est prioritaire) devient alors le nouveau Diablotin.",


"Baron":"Si le Baron est en jeu, deux rôles Étrangers sont automatiquement ajoutés à la composition.",


"Empoisonneur":"Chaque nuit, l'Empoisonneur empoisonne un joueur. Durant cette nuit et cette journée, le joueur empoisonné recevra des informations erronées ",


"Espion":"L'Espion apparaît comme Citadin dans n'importe quelle situation. La première nuit, il reçoit les rôles de TOUS les joueurs.",


"Femme ecarlate":"Si cinq joueurs (ou plus) sont encore en vie à la mort du Diablotin, la Femme Écarlate devient Diablotin à sa place.",


"Archivite":"La première nuit, deux joueurs ainsi qu'un rôle Étranger spécifique sont indiqués à l'Archiviste. Parmi ces deux joueurs se trouve ce rôle Étranger.",


"Croque-mort":"Si le Croque-Mort meurt la nuit, il se réveille alors pour désigner un joueur dont il apprendra l'identité. Il peut désigner un joueur mort.",


"Cuistot":"La première nuit, le Chef est mis au courant du nombre de \"paires\" de Démons autour de la table. Est considérée comme \"paire\" : deux Démons côte à côte. Si trois Démons sont d'affilée, alors il y a deux paires. Si aucun Démon n'est à côté d'un autre, alors il y a 0 paire.",


"Empathe":"Chaque nuit, l'Empathe apprend le nombre de Méchants directement à côté d'elle (0, 1 ou 2). Les joueurs morts ne sont pas pris en compte.",


"Enqueteur":"La première nuit, deux joueurs ainsi qu'un rôle Sbire spécifique sont indiqués à l'Enquêteur. Parmi ces deux joueurs se trouve ce rôle Sbire.",


"Fossoyeur":"Chaque nuit, si un joueur a été exécuté au vote lors de cette journée, le Fossoyeur apprendra l'identité de l'exécuté. Si le joueur exécuté était l'Ivrogne, le Fossoyeur verra le rôle d'Ivrogne et non le faux rôle attribué.",


"Lavandiere":"La première nuit, deux joueurs ainsi qu'un rôle Citadin spécifique sont indiqués à la Lavandière. Parmi ces deux joueurs se trouve ce rôle Citadin.",


"Maire":"Si le Maire est ciblé par le Diablotin la nuit, un autre joueur PEUT (selon le bon vouloir du MJ) mourir à sa place. Aussi, lorsqu'il reste trois joueurs en vie, si la journée se termine sans exécution, la partie se termine instantanément sur une victoire des Citadins.",


"Moine":"Chaque nuit, le Moine choisit un joueur autre que lui-même. Ce joueur ne peut pas mourir par le Démon cette nuit. Il peut choisir le même joueur plusieurs fois d'affilée",


"Pourfendeur":"Une fois par partie, pendant la journée, le Pourfendeur peut désigner une cible aux yeux de tous. Si cette cible est le Diablotin, le Diablotin meurt. Si cette cible n'est pas le Diablotin, rien ne se passe.",


"Soldat":"Le Soldat ne peut pas mourir du Diablotin la nuit. S'il est ciblé, rien ne se passe.",


"Vierge":"Si la Vierge est nommée au vote et que le joueur qui l'a designée est un Citadin (Étrangers exclus), ce joueur est instantanément exécuté. Cette situation ne peut se produire qu'une fois.",


"Voyante":"Chaque nuit, la Voyante choisit deux joueurs. Elle apprendra alors si le Diablotin se trouve parmi les deux. Cependant, l'un des Citadins (appelé le \"Leurre\"), choisi aléatoirement en début de partie par le MJ, apparaîtra comme Diablotin pour elle tout au long de la partie. Elle peut se choisir elle-même ainsi que des joueurs morts.",


"Ivrogne":"L'Ivrogne ne sait pas qu'il l'est. Il croit être un rôle Citadin tout le long, mais ses pouvoirs sont en réalité inexistants. S'il se croit rôle à info, à chaque fois qu'il reçoit ses infos, le MJ lui en donne des aléatoires, Pour les autres rôles à info, il apparaît comme étant le rôle faussement attribué et non comme l'Ivrogne (sauf pour l'Archiviste et le Fossoyeur).",

"Majordome":"Chaque nuit, il désigne son Maître. Il ne pourra voter QUE si son Maître décide de voter.",


"Reclut":"À chaque action effectuée sur le Reclus, le Reclus PEUT apparaître comme un rôle totalement aléatoire. Il PEUT donc apparaître comme Démon aux yeux des rôles à info.",


"Saint":"Si le Saint est exécuté au vote, les Citadins perdent instantanément la partie."}


RoleCamps={
    "Diablotin":"Sbire",
    "Baron":"Sbire",
    "Empoisonneur":"Sbire",
    "Espion":"Sbire",
    "Femme ecarlate":"Sbire",
    "Archiviste":"Citadin",
    "Croque-mort":"Citadin",
    "Cuistot":"Citadin",
    "Empathe":"Citadin",
    "Enqueteur":"Citadin",
    "Fossoyeur":"Citadin",
    "Lavandiere":"Citadin",
    "Maire":"Citadin",
    "Moine":"Citadin",
    "Pourfendeur":"Citadin",
    "Soldat":"Citadin",
    "Vierge":"Citadin",
    "Voyante":"Citadin",
    "Ivrogne":"Etranger",
    "Majordome":"Etranger",
    "Reclus":"Etranger",
    "Saint":"Etranger"}

class PlayerData:
    def __init__(self, name, adress, port, socket):
        self.name = name
        self.id = randint(0, 100000)
        self.adress = adress
        self.port = port
        self.socket = socket







class Choice:
    def __init__(self, type, plys, strs, instruct, time):
        self.id = "choix" + str(randint(0, 1000))

        self.type = type
        self.plys = plys
        self.strs = strs
        self.instruct = instruct
        self.time = time

        """
        type = 1 -> choix de joueur, ne pas considérer la liste str
        type = 2 -> choix str parmis proposés (4 max)
        type = 3 -> choix booléan

        """
        self.receipt = {plys[i].name: False for i in len(plys)}
        self.answer = {plys[i].name: "" for i in len(plys)}



    def to_dict(self):
        """Convertit l'objet en dictionnaire pour le JSON"""
        return {
            "action": "choice",
            "id": self.id,
            "type": self.type,
            "instruct": self.instruct,
            "timeout": self.time
        }

    def run(self):
        data = self.to_dict()
        json_data = json.dumps(data)+ "\n"
        for p in self.plys:
            p.socket.send(json_data.encode('utf-8'))



    def getAnswers(self):
        return self.answer










class Game:
    def __init__(self, id, connected_clients):
        self.id = id
        self.plysData = {}
        for name, sock in connected_clients.items():

            addr, port = sock.getpeername()

            self.plysData[name] = PlayerData(name, addr, port, sock)

        self.plys = list(self.plysData.keys())
        self.finished = False
        self.roles = {}
        self.statuts = {}
        self.nightNb = 1

        self.choices = []
        self.roleChoiceId = {}


        self.rolesLists = {1: ["Diablotin"], 2: ["Diablotin", "Enquêteur"]}
        self.schedule = {}





    def to_chatDict(self, str, isFromSystem, fromPlayer = "", private = False):
        """Convertit l'objet en dictionnaire pour le JSON"""
        return {
            "action": "chat",
            "content": str,
            "fromPlayer": fromPlayer,
            "private": private

        }


    def chat(self, players, str, isFromSystem, fromPlayer = "", private = False):
       for p in players:
           #ici j'ai refait pareil que l'envoie de donnée dans Choice mais en une seule ligne histoire d'économiser

           if p in self.plysData:
                self.plysData[p].socket.send((json.dumps(self.to_chatDict(str, isFromSystem, fromPlayer, private))+ "\n").encode('utf-8'))


    def join(self, name, adress, port, socket):
        for ply in self.plys:
            if self.plysData[ply].adress == adress and self.plysData[ply].port == port:
                return
            else:
                self.plys.append(name)
                self.plysData[name] = PlayerData(name, adress, port, socket)



    def handle_client_messages(self, player_name, conn):
        while True:
            try:
                print("received data")
                data = conn.recv(2048).decode('utf-8')
                print("decoded data")
                if not data: break

                msg_data = json.loads(data)
                print("loaded data")

                #on traite que les messages de type "chat"
                if msg_data.get("action") == "chat":
                    print("data is type chat")
                    content = msg_data.get("content", "")

                    # --- Logique de message privés ---
                    if content.startswith("/"):
                        #on sépare le premier mot
                        parts = content.split(" ", 1)
                        target_name = parts[0][1:]  # On enlève le "/"

                        if target_name in self.plysData:
                            message_prive = parts[1] if len(parts) > 1 else "..."

                            #envoie le message aux deux joueurs
                            self.chat([target_name], message_prive, False, fromPlayer=f"(Privé) {player_name}")
                            self.chat([player_name], message_prive, False, fromPlayer=f"À {target_name}")
                        else:
                            self.chat([player_name], f"Joueur {target_name} introuvable.", True)

                    # si pas privé public
                    else:
                        #envoyer à tout le monde
                        print("envoi de: ", content)
                        self.chat(self.plys, content, False, fromPlayer=player_name)

                elif msg_data.get("action") == "choiceAnswer":
                    self.getChoice(msg_data.get("id")).answer[player_name] = msg_data.get("answer")

            except:
                break


    def start(self):
        self.chat(self.plys, "La partie commence: ", True, "")
        self.chat(self.plys, "Attriution des rôles ", True, "")


        #distribution des rôles
        rolesCopie = self.rolesLists[len(self.plys)]
        for ply in self.plys:
            x = randint(0, len(rolesCopie) - 1)
            self.roles[ply] = rolesCopie[x]
            self.chat([ply], ("Vous êtes" + self.roles[ply]), False, "")
            rolesCopie.pop(x)

            self.statuts[ply] = True
            self.plysData[ply].socket.send(json.dumps({
                "action": "players",
                "list": self.plys
            }).encode('utf-8'))

        # Lancer l'écoute pour chaque joueur
        for name in self.plys:
            t = threading.Thread(target=self.handle_client_messages, args=(name, self.plysData[name].socket))
            t.daemon = True  # Le thread se stoppe si le programme principal s'arrête
            t.start()


        self.night()



        while not self.finished:
            time.sleep(1)  # pour pas faire surchauffer le pc
            current_t = time.time()


            for k in self.schedule.keys():
                if time() - k > self.schedule[k][0]:
                    if self.schedule[k][1] == "night":
                        self.night()
                        self.plysData[ply].socket.send(json.dumps({
                            "action": "phase",
                            "value": "night"
                        }).encode('utf-8'))
                    elif self.schedule[k][1] == "day":
                        self.day()
                        self.plysData[ply].socket.send(json.dumps({
                            "action": "phase",
                            "value": "day"
                        }).encode('utf-8'))
                    elif self.schedule[k][1] == "vote":
                        self.vote()
                    elif self.schedule[k][1] == "voteEnd":
                        self.endVote(self.schedule[k][2])

                    del self.schedule[k]







    def nightAct(role, ply):
        pass




    def night(self):

        for ply in self.plys:
            self.nightAct(self.roles[ply], ply)

        self.nightNb = self.nightNb + 1
        self.schedule[time()] = (120, "day", self.nightNb)


    def morningAct(self):
        pass


    def day(self):

        self.chat(self.plys, "le jour se lève et les joueurs suivants sont morts ", True, "")
        for name in self.statuts.keys():
            if not self.statuts[name]:
                self.chat(self.plys, name, True, "")

        for ply in self.plys:
            self.morningAct(self.roles[ply], ply)

        self.schedule[time()] = (120, "vote", self.nightNb)





    def getChoice(self, id):
        for c in self.choices:
            if c.id == id:
                return c

    def vote(self):

        self.chat(self.plys, "Les votes commencent, veuillez choisir qui mourra ce matin: ", True, "")

        votes = Choice(1, self.plys, [], "Choisissez un joueur à éliminer")
        votes.run()

        self.choices.append(votes)
        self.schedule[time()] = (120, "VoteEnd", votes.id)



    def onDied(self, ply):
        pass

    def endVote(self, id):
        global RoleCamps
        voted = {}
        for k in self.getChoice(id).answer.keys():
            if not voted[self.getChoice(id).answer[k]] is None:
                voted[self.getChoice(id).answer[k]] = voted[self.getChoice(id).answer[k]] + 1
            else:
                voted[self.getChoice(id).answer[k]] = 1


        mostVoted = ""
        for ply in self.plys:
            if mostVoted == "" or voted[ply] > voted[mostVoted]:
                mostVoted = ply


        self.chat(self.plys, ("Les votes se finissent: ainsi le joueur exécuté sera: "+mostVoted), True, "")
        self.statuts[ply] = False
        self.onDied(ply)

        if self.roles[ply] == "Diablotin":
            self.chat(self.plys, (mostVoted+ " était diablotin, les citadins ont gagnés"), True, "")
            self.finished = True


        wonByD = True
        for p in self.plys:
            if not RoleCamps[self.roles[p]] == "Sbire":
                wonByD = False

        if wonByD:
            self.chat(self.plys, ("Il ne reste plus de citadin, les sbire ont gagnés"), True, "")
            self.finished = True


        self.nightNb = self.nightNb + 1
        self.night()





class ServerLobby:
    def __init__(self, host='0.0.0.0', port=5555):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.bind((host, port))
        self.sock.listen(15)  #on autorise jusqu'à 15 connexions en attente

        self.clients = {}  # format: { "NomJoueur": socket_objet }
        self.is_accepting = True
        print(f"Lobby ouvert sur {host}:{port}. En attente de joueurs...")

    def listen_for_connections(self):

        while self.is_accepting:
            try:

                conn, addr = self.sock.accept()

                # Le client doit envoyer son nom immédiatement après la connexion
                data = conn.recv(1024).decode('utf-8')
                player_info = json.loads(data)
                player_name = player_info.get("name", f"Inconnu_{addr[1]}")

                if player_name in self.clients:
                    # Erreur si le nom est déjà pris
                    conn.send(json.dumps({"status": "error", "message": "Nom déjà pris"}).encode())
                    conn.close()
                else:
                    self.clients[player_name] = conn
                    print(f"[NOUVEAU] {player_name} s'est connecté ({addr[0]})")


                    conn.send((json.dumps({"action": "chat", "isSystem": True,"status": "success", "content": "Bienvenue dans le salon d'attente de Blood on the Clocktower"}) + "\n").encode())


                    self.broadcast_system(f"{player_name} a rejoint le salon d'attente.")

            except Exception as e:
                if self.is_accepting:
                    print(f"Erreur connexion: {e}")
                break

    def broadcast_system(self, text):
        """Envoie un message global à tout le monde."""
        msg = json.dumps({"action": "chat", "isSystem": True, "content": text}) + "\n"
        for c in self.clients.values():
            try:
                c.send(msg.encode())
            except:
                pass

    def stop_accepting(self):
        """Ferme les portes du lobby une fois la partie lancée."""
        self.is_accepting = False
        #on ne ferme pas la socket principale ici pour garder les joueurs,
        #mais on arrête la boucle accept()




# --- Initialisation ---
hostname = socket.gethostname()
IPAddr = socket.gethostbyname(hostname)
print("L'ip est ", IPAddr)
lobby = ServerLobby(IPAddr)

# On lance l'écoute dans un thread pour ne pas bloquer le terminal
thread_connexion = threading.Thread(target=lobby.listen_for_connections, daemon=True)
thread_connexion.start()

# --- Phase d'attente ---
while True:
    cmd = input("Tapez 'start' pour lancer la partie ou 'list' pour voir les joueurs : \n")

    if cmd == "list":
        print(f"Joueurs connectés ({len(lobby.clients)}) : {list(lobby.clients.keys())}")

    elif cmd == "start":
        if len(lobby.clients) < 5 and False:  # Exemple: minimum 5 joueurs pour BotC
            print("Pas assez de joueurs pour commencer.")
            continue

        print("Lancement de la partie...")
        lobby.stop_accepting()  # On n'accepte plus de nouveaux entrants
        break

# --- Initialisation de la game ---

mon_jeu = Game(id=1, connected_clients=lobby.clients)
mon_jeu.start()
