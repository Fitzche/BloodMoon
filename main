from random import *
from enum import Enum
import time
import socket
import json
import threading



PHASE_TIME = 12

roleDes= {"Diablotin":"Le Diablotin est le chef des Démons. Chaque nuit, il choisit de tuer quelqu'un. Il est mis au courant de trois rôles qui ne sont pas présents dans la partie. Si le Diablotin meurt, les Citadins gagnent. Mais s'il décide de se viser lui-même la nuit, il meurt et un Sbire choisi aléatoirement (la Femme Écarlate est prioritaire) devient alors le nouveau Diablotin.",


"Baron":"Si le Baron est en jeu, deux rôles Étrangers sont automatiquement ajoutés à la composition.",


"Empoisonneur":"A une occasion, l'Empoisonneur empoisonne un joueur. Durant cette nuit et cette journée, le joueur empoisonné recevra des informations erronées ",


"Espion":"L'Espion apparaît comme Citadin dans n'importe quelle situation. La première nuit, il reçoit les rôles de TOUS les joueurs.",


"Femme ecarlate":"Si cinq joueurs (ou plus) sont encore en vie à la mort du Diablotin, la Femme Écarlate devient Diablotin à sa place.",


"Archiviste":"La première nuit, deux joueurs ainsi qu'un rôle Étranger spécifique sont indiqués à l'Archiviste. Parmi ces deux joueurs se trouve ce rôle Étranger.",


"Croque-mort":"Si le Croque-Mort meurt la nuit, il se réveille alors pour désigner un joueur dont il apprendra l'identité. Il peut désigner un joueur mort.",


"Cuistot":"La première nuit, le Chef est mis au courant du nombre de \"paires\" de Démons autour de la table. Est considérée comme \"paire\" : deux Démons côte à côte. Si trois Démons sont d'affilée, alors il y a deux paires. Si aucun Démon n'est à côté d'un autre, alors il y a 0 paire.",


"Empathe":"Chaque nuit, l'Empathe apprend le nombre de Méchants directement à côté d'elle (0, 1 ou 2). Les joueurs morts ne sont pas pris en compte.",


"Enqueteur":"La première nuit, deux joueurs ainsi qu'un rôle Sbire spécifique sont indiqués à l'Enquêteur. Parmi ces deux joueurs se trouve ce rôle Sbire.",


"Fossoyeur":"Chaque nuit, si un joueur a été exécuté au vote lors de cette journée, le Fossoyeur apprendra l'identité de l'exécuté. Si le joueur exécuté était l'Ivrogne, le Fossoyeur verra le faux rôle attribué et non le role d'Ivrogne.",


"Lavandiere":"La première nuit, deux joueurs ainsi qu'un rôle Citadin spécifique sont indiqués à la Lavandière. Parmi ces deux joueurs se trouve ce rôle Citadin.",


"Maire":"Si le Maire est ciblé par le Diablotin la nuit, un joueur à coté de lui mourra à sa place",


"Moine":"Chaque nuit, le Moine choisit un joueur autre que lui-même. Ce joueur ne peut pas mourir par le Démon cette nuit. Il peut choisir le même joueur plusieurs fois d'affilée",


"Pourfendeur":"Une fois par partie, pendant la journée, le Pourfendeur peut désigner une cible avec la commande /pourfendre [nomDeLaCible] . Si cette cible est le Diablotin, le Diablotin meurt. Si cette cible n'est pas le Diablotin, rien ne se passe.",


"Soldat":"Le Soldat ne peut pas mourir du Diablotin la nuit. S'il est ciblé, rien ne se passe.",


"Vierge":"Si la Vierge est nommée au vote et que le joueur qui l'a designée est un Citadin (Étrangers exclus), ce joueur est instantanément exécuté. Cette situation ne peut se produire qu'une fois.",


"Voyante":"Chaque nuit, la Voyante choisit un joueur, elle obtiendra alors deux roles dont celui du joueur choisit",


"Ivrogne":"L'Ivrogne ne sait pas qu'il l'est. Il croit être un rôle Citadin tout le long, mais ses pouvoirs sont en réalité inexistants. S'il se croit rôle à info, à chaque fois qu'il reçoit ses infos, le MJ lui en donne des aléatoires, Pour les autres rôles à info, il apparaît comme étant le rôle faussement attribué et non comme l'Ivrogne (sauf pour l'Archiviste et le Fossoyeur).",

"Majordome":"Chaque nuit, il désigne son Maître. Le vote du majordome se dirigera automatiquement vers la cible de son maitre",


"Reclus":"Si le reclus est désigné au vote, il ne pourra pas voter à ce vote",


"Saint":"Si le Saint est exécuté au vote, les Citadins perdent instantanément la partie."}


RoleCamps={
    "Diablotin":"Sbire",
    "Baron":"Sbire",
    "Empoisonneur":"Sbire",
    "Espion":"Sbire",
    "Femme ecarlate":"Sbire",
    "Archiviste":"Citadin",
    "Croque-mort":"Citadin",
    "Cuistot":"Citadin",
    "Empathe":"Citadin",
    "Enqueteur":"Citadin",
    "Fossoyeur":"Citadin",
    "Lavandiere":"Citadin",
    "Maire":"Citadin",
    "Moine":"Citadin",
    "Pourfendeur":"Citadin",
    "Soldat":"Citadin",
    "Vierge":"Citadin",
    "Voyante":"Citadin",
    "Ivrogne":"Etranger",
    "Majordome":"Etranger",
    "Reclus":"Etranger",
    "Saint":"Etranger"}

class PlayerData:
    def __init__(self, name, adress, port, socket):
        self.name = name
        self.id = randint(0, 100000)
        self.adress = adress
        self.port = port
        self.socket = socket







class Choice:
    def __init__(self, type, plys, strs, instruct, time):
        self.id = "choix" + str(randint(0, 1000))

        self.type = type
        self.plys = plys
        self.strs = strs
        self.instruct = instruct
        self.time = time
        

        """
        type = 1 -> choix de joueur, ne pas considérer la liste str
        type = 2 -> choix str parmis proposés (4 max)
        type = 3 -> choix booléan

        """
        self.receipt = {plys[i].name: False for i in range(len(plys))}
        self.answer = {plys[i].name: "" for i in range(len(plys))}



    def to_dict(self):
        #convertit en dictionnaire pour json pour socket
        return {
            "action": "choice",
            "id": self.id,
            "type": self.type,
            "instruct": self.instruct,
            "choices": self.strs,
            "timeout": self.time
        }

    def run(self, game):
        game.choices.append(self)
        data = self.to_dict()
        json_data = json.dumps(data)+ "\n"
        for p in self.plys:
            p.socket.send(json_data.encode('utf-8'))



    def getAnswers(self):
        return self.answer










class Game:
    def __init__(self, id, connected_clients):
        self.id = id
        self.plysData = {}
        for name, sock in connected_clients.items():

            addr, port = sock.getpeername()

            self.plysData[name] = PlayerData(name, addr, port, sock)

        self.plys = list(self.plysData.keys())
        self.finished = False
        self.roles = {}
        self.statuts = {name: True for name in self.plys}
        self.nightNb = 1
        self.poisonned = {name: False for name in self.plys}
        self.ecarlate = False
        self.choices = []
        self.roleChoiceId = {}

        self.designed = {name: False for name in self.plys}
        self.viergeDesigner = ""

        self.rolesLists = {
        1:["Diablotin"],
        2:["Diablotin", "Enqueteur"],
        3:["Diablotin", "Enqueteur", "Cuistot"],
        4:["Diablotin", "Enqueteur", "Cuistot", "Empathe"],
        5:["Diablotin", "Enqueteur", "Cuistot", "Empathe", "Empoisonneur"],
        6:["Diablotin", "Enqueteur", "Cuistot", "Empathe", "Empoisonneur", "Fossoyeur"],
        7:["Diablotin", "Enqueteur", "Cuistot", "Empathe", "Empoisonneur", "Fossoyeur", "Lavandiere"],
        8:["Diablotin", "Enqueteur", "Cuistot", "Empathe", "Empoisonneur", "Fossoyeur", "Lavandiere", "Maire"],
        9:["Diablotin", "Enqueteur", "Cuistot", "Empathe", "Empoisonneur", "Fossoyeur", "Lavandiere", "Maire", "Soldat"],
        10:["Diablotin", "Enqueteur", "Cuistot", "Empathe", "Empoisonneur", "Fossoyeur", "Lavandiere", "Saint","Ivrogne", "Baron"],
        11:["Diablotin", "Enqueteur", "Cuistot", "Empathe", "Empoisonneur", "Fossoyeur", "Lavandiere", "Saint","Ivrogne", "Baron","Pourfendeur"],
        12:["Diablotin", "Enqueteur", "Cuistot", "Empathe", "Empoisonneur", "Fossoyeur", "Lavandiere", "Saint","Ivrogne", "Baron","Pourfendeur", "Moine"],
        13:["Diablotin", "Enqueteur", "Cuistot", "Empathe", "Empoisonneur", "Fossoyeur", "Lavandiere", "Saint","Ivrogne", "Baron","Pourfendeur", "Moine", "Espion"],
        14:["Diablotin", "Enqueteur", "Cuistot", "Empathe", "Empoisonneur", "Fossoyeur", "Lavandiere", "Saint","Ivrogne", "Baron","Pourfendeur", "Moine", "Espion", "Majordome"],
        15:["Diablotin", "Enqueteur", "Cuistot", "Empathe", "Empoisonneur", "Fossoyeur", "Lavandiere", "Saint","Ivrogne", "Baron","Pourfendeur", "Moine", "Espion", "Majordome", "Voyante"],
        16:["Diablotin", "Enqueteur", "Cuistot", "Empathe", "Empoisonneur", "Fossoyeur", "Lavandiere", "Saint","Ivrogne", "Baron","Pourfendeur", "Moine", "Espion", "Majordome", "Voyante", "Vierge"],
        17:["Diablotin", "Enqueteur", "Cuistot", "Empathe", "Empoisonneur", "Fossoyeur", "Lavandiere", "Saint","Ivrogne", "Baron","Pourfendeur", "Moine", "Espion", "Majordome", "Voyante", "Vierge", "Maire"],
        18:["Diablotin", "Enqueteur", "Cuistot", "Empathe", "Empoisonneur", "Fossoyeur", "Lavandiere", "Saint","Ivrogne", "Baron","Pourfendeur", "Moine", "Espion", "Majordome", "Voyante", "Vierge", "Maire", "Croque-mort"],
        19:["Diablotin", "Enqueteur", "Cuistot", "Empathe", "Empoisonneur", "Fossoyeur", "Lavandiere", "Saint","Ivrogne", "Baron","Pourfendeur", "Moine", "Espion", "Majordome", "Voyante", "Vierge", "Maire", "Croque-mort", "Reclus"],
        20:["Diablotin", "Enqueteur", "Cuistot", "Empathe", "Empoisonneur", "Fossoyeur", "Lavandiere", "Saint","Ivrogne", "Baron","Pourfendeur", "Moine", "Espion", "Majordome", "Voyante", "Vierge", "Maire", "Croque-mort", "Reclus", "Archiviste"]
        }
        self.schedule = {}





    def to_chatDict(self, str, isFromSystem, fromPlayer = "", private = False):
        """Convertit l'objet en dictionnaire pour le JSON"""
        return {
            "action": "chat",
            "content": str,
            "fromPlayer": fromPlayer,
            "private": private

        }


    def chat(self, players, str, isFromSystem, fromPlayer = "", private = False):
       for p in players:
           #ici j'ai refait pareil que l'envoie de donnée dans Choice mais en une seule ligne histoire d'économiser

           if p in self.plysData:

               self.plysData[p].socket.send((json.dumps(self.to_chatDict(str, isFromSystem, fromPlayer, private))+ "\n").encode())


    def join(self, name, adress, port, socket):
        for ply in self.plys:
            if self.plysData[ply].adress == adress and self.plysData[ply].port == port:
                return
            else:
                self.plys.append(name)
                self.plysData[name] = PlayerData(name, adress, port, socket)



    def handle_client_messages(self, player_name, conn):

        while True:
            try:

                data = conn.recv(2048).decode()

                if not data: break

                msg_data = json.loads(data)


                #on traite que les messages de type "chat"
                if msg_data.get("action") == "chat":

                    print("data is type chat")
                    content = msg_data.get("content", "")

                    if content.startswith("/designer"):
                        # on sépare le premier mot
                        parts = content.split(" ", 9)
                        target_name = parts[0][1:]  # On enlève le "/"

                        if target_name in self.plysData:
                            if not self.statuts[player_name]:
                                self.chat([player_name], "Vous ne pouvez effectuer cette commande en étant mort", True)
                            else:
                                self.chat(self.plys, "Le joueur "+ player_name+ " a désigné le joueur "+ target_name, True)
                                self.designed[target_name] = True

                                if self.roles[target_name] == "Vierge":
                                    self.viergeDesigner = player_name

                    elif content.startswith("/pourfendre"):
                        #on sépare le premier mot
                        parts = content.split(" ", 11)
                        target_name = parts[0][1:]  # On enlève le "/"

                        if target_name in self.plysData:
                            if not self.statuts[player_name]:
                                self.chat([player_name], "Vous ne pouvez effectuer cette commande en étant mort", True)
                            elif self.roles[target_name] == "Diablotin":
                                self.chat(self.plys, "Le joueur "+ player_name + " était pourfendeur et a trouvé le diablotin "+ target_name+ ", la partie est donc gagné par les citadins", True)
                                self.finished = True
                            else:
                                self.chat([player_name], "Mauvaise pioche !", True)

                    elif content.startswith("/"):
                        #on sépare le premier mot
                        parts = content.split(" ", 1)
                        target_name = parts[0][1:]  # On enlève le "/"

                        if target_name in self.plysData:
                            message_prive = parts[1] if len(parts) > 1 else "..."

                            #envoie le message aux deux joueurs
                            self.chat([target_name], message_prive, False, fromPlayer=f"(Privé) {player_name}")
                            self.chat([player_name], message_prive, False, fromPlayer=f"À {target_name}")


                        else:
                            self.chat([player_name], f"Joueur {target_name} introuvable.", True)

                    # si pas privé public
                    else:
                        #envoyer à tout le monde
                        print("envoi de: ", content)

                        self.chat(self.plys, content, True, player_name)

                elif msg_data.get("action") == "choiceAnswer":
                    print("choice answer")
                    print("id: "+ msg_data.get("id"))
                    print("answer: "+msg_data.get("answer"))

                    choix = self.getChoice(msg_data.get("id"))
                    if not choix == None and not choix == '':
                        choix.answer[player_name] = msg_data.get("answer")

            except Exception as e:
                print(e)
                break


    def start(self):
        self.chat(self.plys, "La partie commence: ", True, "")
        self.chat(self.plys, "Attribution des rôles ", True, "")




        #distribution des rôles
        rolesCopie = []

        for r in self.rolesLists[len(self.plys)]:
            rolesCopie.append(r)

        for ply in self.plys:
            x = randint(0, len(rolesCopie) - 1)
            self.roles[ply] = rolesCopie[x]
            print(rolesCopie[x] + " for " + ply)
            if self.roles[ply] == "Ivrogne":
                rolesIvrogne = ["Archiviste", "Croque-Mort", "Cuistot", "Empathe", "Enqueteur", "Fossoyeur",
                                "Lavandiere", "Voyante"]
                self.roles[ply] = rolesIvrogne[randint(0, len(rolesIvrogne) - 1)]
                self.poisonned[ply] = True

            self.chat([ply], ("Vous êtes" + self.roles[ply] + " "), True, "")
            self.chat([ply], (roleDes[self.roles[ply]]), True, "")
            rolesCopie.pop(x)


        for ply in self.plys:





            # Information du Diablotin au début du jeu
            if self.roles[ply] == "Diablotin":


                role1 = self.rolesLists[len(self.plys)][randint(0,len(self.rolesLists[len(self.plys)]) -1)]
                role2 = self.rolesLists[len(self.plys)][randint(0,len(self.rolesLists[len(self.plys)]) -1)]
                role3 = self.rolesLists[len(self.plys)][randint(0,len(self.rolesLists[len(self.plys)]) -1)]
                self.chat([ply], ("Dans la game il y a les roles: " + role1 + "; "+ role2 + "; "+ role3), False, "")


            # Information de l'Archiviste au début du jeu
            elif self.roles[ply] == "Archiviste":
                for p in self.plys:



                    if RoleCamps[self.roles[p]] == "Etranger":
                        name = self.plys[randint(0, len(self.plys))]

                        #fausse information si l'archiviste est empoisonné
                        if self.poisonned[ply] == True:
                            name2 = self.plys[randint(0, len(self.plys))]
                            self.chat([ply], ("Le role "+ self.roles[p] + " appartient à "+ name + " ou "+ name2), True, "", True)
                        else:

                            #fait apparaitre les deux noms de manière aléatoire pour éviter que les joueurs sache lequel est le vrai role
                            if randint(0, 100) > 50:
                                self.chat([ply], ("Le role "+ self.roles[p] + " appartient à "+ name + " ou "+ p), True, "", True)
                            else:
                                self.chat([ply], ("Le role "+ self.roles[p] + " appartient à "+ p + " ou "+ name), True, "", True)
            elif self.roles[ply] == "Espion":
                for k in self.plys:

                    self.chat([ply], ("Le joueur "+ k + " est "+self.roles[k]))
            elif self.roles[ply] == "Cuistot":
                x = 0
                for p in self.plys:
                    if RoleCamps[self.roles[ply]] == "Sbire" and self.plys.index(p) +1<=len(self.plys) and self.plys.index(p) > 0 and RoleCamps[self.plys[self.plys.index(p) +1]] == "Sbire" and not RoleCamps[self.plys[self.plys.index(p) -1]]:
                        x = x +1
                if self.poisonned[ply]:
                    self.chat([ply], ("Le nombre de paires est de " + "0"),True)

                else:
                    self.chat([ply], ("Le nombre de paires est de " + str(x)),True)
            elif self.roles[ply] == "Enqueteur":
                for p in self.plys:



                    if RoleCamps[self.roles[p]] == "Sbire" and not self.roles[p] == "Espion":
                        name = self.plys[randint(0, len(self.plys) -1)]

                        #fausse information si l'enqueteur est empoisonné
                        if self.poisonned[ply] == True:
                            name2 = self.plys[randint(0, len(self.plys))]
                            self.chat([ply], ("Le role "+ self.roles[p] + " appartient à "+ name + " ou "+ name2), True, "", True)
                        else:

                            #fait apparaitre les deux noms de manière aléatoire pour éviter que les joueurs sache lequel est le vrai role
                            if randint(0, 100) > 50:
                                self.chat([ply], ("Le role "+ self.roles[p] + " appartient à "+ name + " ou "+ p), True, "", True)
                            else:
                                self.chat([ply], ("Le role "+ self.roles[p] + " appartient à "+ p + " ou "+ name), True, "", True)
            elif self.roles[ply] == "Lavandiere":
                for p in self.plys:

                    if RoleCamps[self.roles[p]] == "Citadin":
                        name = self.plys[randint(0, len(self.plys))]

                        # fausse information si la lavandière est empoisonné
                        if self.poisonned[ply] == True:
                            name2 = self.plys[randint(0, len(self.plys))]
                            self.chat([ply], ("Le role " + self.roles[p] + " appartient à " + name + " ou " + name2),
                                      True, "", True)
                        else:

                            # fait apparaitre les deux noms de manière aléatoire pour éviter que les joueurs sache lequel est le vrai role
                            if randint(0, 100) > 50:
                                self.chat([ply], ("Le role " + self.roles[p] + " appartient à " + name + " ou " + p),
                                          True, "", True)
                            else:
                                self.chat([ply], ("Le role " + self.roles[p] + " appartient à " + p + " ou " + name),
                                          True, "", True)



            self.statuts[ply] = True


            self.plysData[ply].socket.send((json.dumps({
                "action": "players",
                "list": self.plys
            } )+ "\n").encode())


        # Lancer l'écoute pour chaque joueur
        for name in self.plys:
            t = threading.Thread(target=self.handle_client_messages, args=(name, self.plysData[name].socket))
            t.daemon = True  # Le thread se stoppe si le programme principal s'arrête
            t.start()



        self.night()



        while not self.finished:
            time.sleep(1)  # pour pas faire surchauffer le pc
            current_t = time.time()

            keysCopie = []
            for key in self.schedule.keys():
                keysCopie.append(key)
            for k in keysCopie:
                if time.time() - k > self.schedule[k][0]:
                    if self.schedule[k][1] == "night":
                        self.night()
                        self.plysData[ply].socket.send((json.dumps({
                            "action": "phase",
                            "value": "night"
                        })+ "\n").encode())
                    elif self.schedule[k][1] == "day":
                        self.day()
                        self.plysData[ply].socket.send((json.dumps({
                            "action": "phase",
                            "value": "day"
                        })+ "\n").encode())
                    elif self.schedule[k][1] == "vote":
                        self.vote()
                    elif self.schedule[k][1] == "voteEnd":
                        self.endVote(self.schedule[k][2])

                    del self.schedule[k]







    def nightAct(self, role, ply):
        if role == "Diablotin":
            c = Choice(1, [self.plysData[ply]], ["1", "2", "3"], "Choisissez un joueur à éliminer (choix de role)", PHASE_TIME)
            self.roleChoiceId["Diablotin"] = c
            c.run(self)
        elif role == "Empoisonneur":
            if self.isChoiceValid("Empoisonneur"):
                self.poisonned = False
            c = Choice(1, [self.plysData[ply]], [], "Choisissez un joueur à empoisonner (choix de role)", PHASE_TIME)
            self.roleChoiceId["Empoisonneur"] = c
            c.run(self)
        elif role == "Moine":

            c = Choice(1, [self.plysData[ply]], [], "Choisissez un joueur à protéger (choix de role)", PHASE_TIME)
            self.roleChoiceId["Moine"] = c
            c.run(self)
        elif role == "Croque-Mort":
            c = Choice(1, [self.plysData[ply]], [], "Choisissez un joueur dont vous connaitrez l'identité si vous venez à mourir de la main du Diablotin (choix de role)", PHASE_TIME)
            self.roleChoiceId["Croque"] = c
            c.run(self)
        elif role == "Voyante":
            c = Choice(1, [self.plysData[ply]], [], "Choisissez un joueur à observer, vous obtiendrez deux roles dont le siens (choix de role)", PHASE_TIME)
            self.roleChoiceId["Voyante"] = c
            c.run(self)
        elif role == "Majordome":
            c = Choice(1, [self.plysData[ply]], [], "Choisissez un joueur qui sera votre maitre au prochain vote (choix de role)", PHASE_TIME)
            self.roleChoiceId["Majordome"] = c
            c.run(self)
        elif role == "Empathe":
            x = 0
            if self.plys.index(ply) > 0 and self.roles[self.plys[self.plys.index(ply) - 1]]:
                x = x + 1
            if self.plys.index(ply) < len(self.plys)-1 and self.roles[self.plys[self.plys.index(ply) - 1]]:
                x = x + 1


            if self.poisonned[ply]:
                self.chat([ply], ("Il y a "+ "0" + " sbires autours de vous."), True)

            else:
                self.chat([ply], ("Il y a "+ str(x) + " sbires autours de vous."), True)



    def night(self):

        for ply in self.plys:
            self.nightAct(self.roles[ply], ply)

        self.nightNb = self.nightNb + 1
        self.schedule[time.time()] = (12, "day", self.nightNb)


    def isChoiceValid(self, choice):
        if choice in self.roleChoiceId and not list(self.roleChoiceId[choice].answer.values())[0] == None and not list(self.roleChoiceId[choice].answer.values())[0] ==  '':
            return True
        else:
            return False

    def morningAct(self):

        if self.isChoiceValid("Diablotin"):
            ply = list(self.roleChoiceId["Diablotin"].answer.values())[0]





            #Annuler la mort si protégé par le moine
            if self.isChoiceValid("Moine") and list(self.roleChoiceId["Moine"].answer.values())[0] == ply:

                print("protected by Moine")
                return

            #dévier la mort si le joueur visé est maire
            if self.roles[ply] == "Maire":
                if self.plys.index(ply) + 1 < len(self.plys):
                    ply = self.plys[self.plys.index(ply) + 1]
                elif self.plys.index(ply) > 0:
                    ply = self.plys[self.plys.index(ply) - 1]
                else:
                    self.chat([ply] , "Il n'y a pas de joueur pouvant etre tué à votre place" ,  True)

            if not self.roles[ply] == "Soldat":


                self.statuts[ply] = False
                self.onDied(ply)


                #Donne le lead des sbire à la femme écarlate si le diablotin se vise lui meme (et si celle ci est encore en vie)
                ecar = False
                for p in self.plys:
                    if self.statuts[p] and self.roles[p] == "Femme ecarlate":
                        ecar = True
                if self.roles[ply] == "Diablotin" and not self.ecarlate == True and ecar:
                    self.ecarlate = True


                #Donne un role au croque mort s'il est tué par le diablotin et s'il a fait un choix
                if self.roles[ply] == "Croque-Mort":
                    if self.isChoiceValid("Croque"):
                        if not self.poisonned[ply]:
                            self.chat([ply],("Le joueur "+ list(self.roleChoiceId["Croque"].answer.values())[0] + " est "+ self.roles[list(self.roleChoiceId["Croque"].answer.values())[0]]) )
                        else:
                            self.chat([ply],("Le joueur "+ list(self.roleChoiceId["Croque"].answer.values())[0] + " est "+ self.rolesLists[20][randint(0, len(self.rolesLists[20]))]))



        else:
            self.chat(self.plys, ("Le diablotin n'a pas fait de victime") ,True)

        if self.isChoiceValid("Empoisonneur"):
            player = list(self.roleChoiceId["Empoisonneur"].answer.values())[0]
            self.poisonned[player] = True

        if self.isChoiceValid("Voyante") and not list(self.roleChoiceId["Voyante"].answer.keys())[0] == None and not list(self.roleChoiceId["Voyante"].answer.keys())[0] == '':
            player = list(self.roleChoiceId["Voyante"].answer.keys())[0]
            target = list(self.roleChoiceId["Voyante"].answer.values())[0]
            roleSec = self.roles[self.plys[randint(0, len(self.plys) - 1)]]
            roleTer = self.roles[self.plys[randint(0, len(self.plys) - 1)]]



            if self.poisonned[player]:
                if randint(0, 100) > 50:
                    self.chat([player], "Le role du joueur "+ target + " est soit "+ roleSec + " soit "+ roleTer, True)
                else:
                    self.chat([player], "Le role du joueur "+ target + " est soit "+ roleTer + " soit "+ roleSec, True)
            else:
                if randint(0, 100) > 50:
                    self.chat([player], "Le role du joueur "+ target + " est soit "+ roleSec + " soit "+ self.roles[target], True)
                else:
                    self.chat([player], "Le role du joueur "+ target + " est soit "+ self.roles[target] + " soit "+ roleSec, True)







    def day(self):

        self.chat(self.plys, "le jour se lève et les joueurs suivants sont morts ", True, "")
        for name in self.statuts.keys():
            if not self.statuts[name]:
                self.chat(self.plys, name, True, "")

        self.morningAct()

        self.schedule[time.time()] = (PHASE_TIME, "vote", self.nightNb)





    def getChoice(self, id):
        for c in self.choices:
            if c.id == id:
                return c

    def vote(self):

        self.chat(self.plys, "Les votes commencent, veuillez choisir qui mourra ce matin: ", True, "")
        self.designed = {name: False for name in self.plys}
        votes = Choice(1, [self.plysData[p] for p in self.plys], [], "Choisissez un joueur à éliminer", PHASE_TIME)
        votes.run(self)


        self.schedule[time.time()] = (PHASE_TIME, "voteEnd", votes.id)



    def onDied(self, ply):

        self.chat(self.plys, ("Le joueur " + ply + " est mort"), True)

        self.statuts[ply] = False
        ecar = False
        for p in self.plys:
            if self.statuts[p] and self.roles[p] == "Femme ecarlate":
                ecar = True

        if self.roles[ply] == "Diablotin" and not ecar:

            self.chat(self.plys, (ply + " était diablotin, les citadins ont gagnés"), True, "")
            self.finished = True
        elif self.roles[ply] == "Diablotin":
            self.ecarlate = True

        if self.roles[ply] == "Femme ecarlate" and self.ecarlate:
            self.chat(self.plys, (ply + " était femme ecarlate, les citadins ont gagnés"), True, "")

        wonByD = True
        for p in self.plys:
            if not RoleCamps[self.roles[p]] == "Sbire":
                wonByD = False

        if wonByD:
            self.chat(self.plys, ("Il ne reste plus de citadin, les sbire ont gagnés"), True, "")
            self.finished = True


        self.plysData[ply].socket.send((json.dumps({
                            "action": "death"
                        })+ "\n").encode('utf-8'))








    def endVote(self, id):
        global RoleCamps
        voted = {}
        for k in self.getChoice(id).answer.keys():

            #vérifie si le role du votant est majordome
            if self.roles[k] == "Majordome":
                #si le joueur désigné par le majordome n'est pas null
                if self.isChoiceValid("Majordome"):

                    #le choix du majordome devient celui de son maitre
                    self.getChoice(id).answer[k] = self.getChoice(id).answer[list(self.roleChoiceId["Majordome"].answer.values())[0]]
                    self.chat([k], "Vous voter pour la cible de votre maitre: "+ self.getChoice(id).answer[list(self.roleChoiceId["Majordome"].answer.values())[0]], True)


                else:
                    self.chat([k], "Vous n'avez pas choisi de maitre, vous ne pouvez donc pas voter", True)

            if self.roles[k] == "Reclus":
                if self.designed[k]:
                    self.chat([k], "Vous ne pouvez pas voter car vous avez été désigné aux votes", True)
                    self.getChoice(id).answer[k] = ""

            if not self.getChoice(id).answer[k] == "":

                if not voted[self.getChoice(id).answer[k]] is None and not voted[self.getChoice(id).answer[k] == '']:
                    voted[self.getChoice(id).answer[k]] = voted[self.getChoice(id).answer[k]] + 1
                else:
                    voted[self.getChoice(id).answer[k]] = 1

                self.chat(self.plys, "Le joueur "+ k + " a voté pour "+ self.getChoice(id).answer[k], True)
            else:
                self.chat(self.plys, "Le joueur n'a pas voté", True)


        mostVoted = ""
        for ply in self.plys:
            if mostVoted == "" or voted[ply] > voted[mostVoted]:
                mostVoted = ply



        ply = mostVoted
        self.chat(self.plys, ("Les votes se finissent: ainsi le joueur exécuté sera: "+mostVoted), True, "")

        if self.designed[ply]:

            self.onDied(ply)

            if self.roles[ply] == "Saint":
                self.chat(self.plys, "Le joueur exécuté était Saint, les citadins perdent donc immédiatement la parie", True)
                self.finished = True

            if self.roles[ply] == "Vierge":
                if self.viergeDesigner in self.plys:

                    self.chat(self.plys, "Le joueur voté était la Vierge, le joueur "+ self.viergeDesigner + " l'ayant désigné meurt donc avec.", True)
                    self.onDied(ply)


            for p in self.plys:
                if self.roles[p] == "Fossoyeur":
                    if self.poisonned[p]:
                        self.chat([ply], ("Le joueur " + ply + " était "+ self.roles[self.plys[randint(0, len(self.plys) - 1)]]), True)

                    else:
                        self.chat([ply], ("Le joueur " + ply + " était "+ self.roles[ply]), True)
        else:
            self.chat(self.plys, "Le joueur le plus voté n'a pas été désigné préalablement, il ne sera donc pas executé")



        self.nightNb = self.nightNb + 1
        self.night()





class ServerLobby:
    def __init__(self, host='0.0.0.0', port=5555):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.bind((host, port))
        self.sock.listen(15)  #on autorise jusqu'à 15 connexions en attente

        self.clients = {}  # format: { "NomJoueur": socket_objet }
        self.is_accepting = True
        print(f"Lobby ouvert sur {host}:{port}. En attente de joueurs...")

    def listen_for_connections(self):

        while self.is_accepting:
            try:

                conn, addr = self.sock.accept()

                # Le client doit envoyer son nom immédiatement après la connexion
                data = conn.recv(1024).decode('utf-8')
                player_info = json.loads(data)
                player_name = player_info.get("name", f"Inconnu_{addr[1]}")

                if player_name in self.clients:
                    # Erreur si le nom est déjà pris
                    conn.send((json.dumps({"status": "error", "message": "Nom déjà pris"})+ "\n").encode())
                    conn.close()
                else:
                    self.clients[player_name] = conn
                    print(f"[NOUVEAU] {player_name} s'est connecté ({addr[0]})")


                    conn.send((json.dumps({"action": "chat", "isSystem": True,"status": "success", "content": "Bienvenue dans le salon d'attente de Blood on the Clocktower"}) + "\n").encode())


                    self.broadcast_system(f"{player_name} a rejoint le salon d'attente.")

            except Exception as e:
                if self.is_accepting:
                    print(f"erreur connexion: {e}")
                break

    def broadcast_system(self, text):
        """Envoie un message global à tout le monde."""
        msg = json.dumps({"action": "chat", "isSystem": True, "content": text}) + "\n"
        for c in self.clients.values():
            try:
                c.send(msg.encode())
            except:
                pass

    def stop_accepting(self):
        """Ferme les portes du lobby une fois la partie lancée."""
        self.is_accepting = False
        #on ne ferme pas la socket principale ici pour garder les joueurs,
        #mais on arrête la boucle accept()




# --- Initialisation ---
hostname = socket.gethostname()
IPAddr = socket.gethostbyname(hostname)
print("L'ip est ", IPAddr)
lobby = ServerLobby(IPAddr)

# On lance l'écoute dans un thread pour ne pas bloquer le terminal
thread_connexion = threading.Thread(target=lobby.listen_for_connections, daemon=True)
thread_connexion.start()

# --- Phase d'attente ---
while True:
    cmd = input("Tapez 'start' pour lancer la partie ou 'list' pour voir les joueurs : \n")

    if cmd == "list":
        print(f"Joueurs connectés ({len(lobby.clients)}) : {list(lobby.clients.keys())}")

    elif cmd == "start":
        if len(lobby.clients) < 5 and False:  # Exemple: minimum 5 joueurs pour BotC
            print("Pas assez de joueurs pour commencer.")
            continue

        print("Lancement de la partie...")
        lobby.stop_accepting()  # On n'accepte plus de nouveaux entrants
        break

# --- Initialisation de la game ---


mon_jeu = Game(id=1, connected_clients=lobby.clients)
mon_jeu.start()
